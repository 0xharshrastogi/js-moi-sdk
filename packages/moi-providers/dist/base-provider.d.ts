/// <reference types="node" />
import { Address, LogicManifest, Tesseract } from "moi-utils";
import { EventType, Listener } from "../types/event";
import { AccountMetaInfo, AccountState, AssetInfo, ContextInfo, InteractionObject, InteractionReceipt, InteractionResponse, Options, TDU, Content, ContentFrom, Status, Inspect, Encoding } from "../types/jsonrpc";
import { AbstractProvider } from "./abstract-provider";
import Event from "./event";
export declare class BaseProvider extends AbstractProvider {
    _events: Array<Event>;
    _pollingInterval: number;
    _poller: NodeJS.Timer;
    _bootstrapPoll: NodeJS.Timer;
    defaultOptions: Options;
    constructor();
    private processResponse;
    getBalance(address: string, assetId: string, options?: Options): Promise<number | bigint>;
    getContextInfo(address: string, options?: Options): Promise<ContextInfo>;
    getTDU(address: string, options?: Options): Promise<TDU>;
    getInteractionCount(address: string, options?: Options): Promise<number | bigint>;
    getPendingInteractionCount(address: string): Promise<number | bigint>;
    getAccountState(address: string, options?: Options): Promise<AccountState>;
    getAccountMetaInfo(address: string, options?: Options): Promise<AccountMetaInfo>;
    getContentFrom(address: string): Promise<ContentFrom>;
    getWaitTime(address: string): Promise<number | bigint>;
    getTesseract(address: string, with_interactions: boolean, options?: Options): Promise<Tesseract>;
    sendInteraction(ixObject: InteractionObject): Promise<InteractionResponse>;
    getAssetInfoByAssetID(assetId: string): Promise<AssetInfo>;
    getInteractionReceipt(ixHash: string): Promise<InteractionReceipt>;
    getStorageAt(logicId: string, storageKey: string, options?: Options): Promise<any>;
    getLogicManifest(logicId: string, encoding: Encoding, options?: Options): Promise<string | LogicManifest.Manifest>;
    getContent(): Promise<Content>;
    getStatus(): Promise<Status>;
    getInspect(): Promise<Inspect>;
    getPeers(): Promise<string[]>;
    getDBEntry(key: string): Promise<string>;
    getAccounts(): Promise<Address[]>;
    waitForInteraction(interactionHash: string, timeout?: number): Promise<InteractionReceipt>;
    waitForResult(interactionHash: string, timeout?: number): Promise<string>;
    execute(method: string, params: any): Promise<any>;
    _startEvent(event: Event): void;
    _stopEvent(event: Event): void;
    _addEventListener(eventName: EventType, listener: Listener, once: boolean): this;
    on(eventName: EventType, listener: Listener): this;
    once(eventName: EventType, listener: Listener): this;
    emit(eventName: EventType, ...args: Array<any>): boolean;
    listenerCount(eventName?: EventType): number;
    listeners(eventName?: EventType): Array<Listener>;
    off(eventName: EventType, listener?: Listener): this;
    removeAllListeners(eventName?: EventType): this;
    get polling(): boolean;
    set polling(value: boolean);
    poll(): Promise<void>;
    get pollingInterval(): number;
    set pollingInterval(value: number);
}
